<script src="https://cdn.jsdelivr.net/gh/netizenorg/netnet-standard-library/build/nn.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.15/paper-full.min.js"></script>
<script>
/* global nn, paper */

let string_thickness = nn.height / 64
let string_spacing = nn.height / 32
let string_color = "#FFFFFF"
let fret_color = "#CB9386"
let nut_color = "#FF2629"
let no_frets = 8

//"hp" means hammer/pull, which refers to
//hammer-ons and pull-offs. 

//I don't have samples for this, so I'm simulating it
//with a sample offset specified in seconds.
let hp_offset = 0.175

//DEFINING AUDIO + LOGISTICAL VARIABLES
class Course {
  constructor(play_keys, fret_keys, mute_key, tuning, subfolder){
    //play_keys is what keys can be pressed to pluck the course.
    this.play_keys = play_keys;
    //play_listeners prevents key events from being rapid-fired
    //while they're held down. I love Javascript!
    this.play_listeners = [true, true];
    //fret_keys is what keys can be pressed to fret the course.
    this.fret_keys = fret_keys;
    //A list of what notes are currently fretted on the course.
    //Dictates the pitch.
    this.fretted = [];
    //The key you press to mute the string.
    this.mute_key = mute_key
    //Is it muted?
    this.muted = false;
    //The tuning of the course, in MIDI notation.
    this.tuning = tuning;
    //The subfolder name the course uses.
    this.subfolder = subfolder;
    //A list of samples used by the course.
    this.sample_set = generate_paths(this.tuning, this.subfolder);
  }
}


//COURSE 1
let c1 = new Course(["NumpadAdd", "NumpadSubtract"],
                   ["Digit1", "Digit2", "Digit3", "Digit4", "Digit5", "Digit6", "Digit7", "Digit8"],
                   ["Backspace"],
                   65,
                   "course_1")
//COURSE 2
let c2 = new Course(["Numpad7", "Numpad8"],
                   ["KeyQ", "KeyW", "KeyE", "KeyR", "KeyT", "KeyY", "KeyU", "KeyI"],
                   ["Backslash"],
                   60,
                   "course_2")

let courses = [c1, c2]

//A for loop to check if courses were properly formed.
//Uncomment if you wanna run it.
//for (let i = 0; i < courses.length; i++){
//  console.log(courses[i])
//}
  
//console.log(generate_paths(c1))
//LOOPING FUNCTIONS
//Functions I use for a plethora of batch operations.

function generate_paths(tuning, subfolder){

let path_list = []
for (let i = tuning; i < tuning + no_frets + 1; i++){
  let note = nn.midiToNote(i)
  if (note.includes("#")){
    note = note.charAt(0) + "s" + note.charAt(2)
  }
  let path = "samples/" + subfolder + "/"  + note + ".mp3"
  //console.log(path)
  path_list.push(nn.create('audio').set({src: path}))
}

return path_list

}
  
//GENERATE FILE PATHS!!!
//COURSE 1


//Check what pitch a course should resonate at.
//fret_max, the variable we're looking for,
//refers to the highest-numbered fret that's being pressed.
function check_frets(course){
  let fret_max = 0
  for (let i = 0; i < course.fretted.length; i++){
    if (course.fretted[i] > fret_max){
      fret_max = course.fretted[i]
    }
  }
  return fret_max
}
   

//Makes a course resonate, whether it's a
//pluck or a hammer-on/pull-off.
function string_sound(course, sample_offset){
  let sample_set = course.sample_set;
    for (let i = 0; i < no_frets + 1; i++){
      if (i === check_frets(course)){
        sample_set[i].currentTime = sample_offset
        //SLIGHT RANDOMIZATION
        sample_set[i].preservesPitch = false
        sample_set[i].volume = 0.9 + nn.randomFloat(0,0.1)
        sample_set[i].playbackRate = 1 + nn.randomFloat(-0.005, 0.005)
        //
        sample_set[i].play()
        //console.log(sample_set[i].src)
      }
      else{
        sample_set[i].pause()
      }
    }  
}

//Mutes a course.  
function mute(course){
  for (let i = 0; i < no_frets + 1; i++){
    course.sample_set[i].pause()
}}

//Checks if any of the samples in a course's
//sample set is playing.
function is_playing(course){
  let value = false
  for (let i = 0; i < no_frets + 1; i++){
    if (course.sample_set[i].paused){
      continue
    }
    else{
      value = true
      return value
      break
    }
  }
  return value
}
  
//AUDIO FUNCTIONALITY
function keydown(event){
  //console.log(event.code)
  
  //EVERY COURSE LISTENS TO KEYDOWN EVENTS!!!
  //To prevent ridiculous amounts of copy-pasting,
  //I'm using a for loop to run these same checks
  //on every course. Don't ask me if that's the ideal way.
  //I don't know.
  for (let i = 0; i < courses.length; i++){
    
  //Make a course resonate
  if (courses[i].play_keys.includes(event.code)){
    let index = courses[i].play_keys.indexOf(event.code)
    if (courses[i].play_listeners[index] === true && !courses[i].muted){
    //console.log("attempting to play c1")
    string_sound(courses[i].sample_set, 0)
    courses[i].play_listeners[index] = false
    }
  }
  
  //Mute Courses
  if (courses[i].mute_key.includes(event.code) && !courses[i].muted){
    courses[i].muted = true
    mute(courses[i])
  }
  
  //Fret Courses
  let before = check_frets(courses[i])
  let fret = courses[i].fret_keys.indexOf(event.code) + 1
  let already_in = courses[i].fretted.includes(fret)
  if (courses[i].fret_keys.includes(event.code) && !already_in){
    courses[i].fretted.push(fret)
    let after = check_frets(courses[i])
    if (is_playing(courses[i]) && before !== after){
      string_sound(courses[i], hp_offset)
    }
  }
}}

async function keyup(event){
  //As with keydown, this is executed on a per-course basis.
  
  for (let i = 0; i < courses.length; i++){
  //Make a course pluckable again
  if (courses[i].play_keys.includes(event.code)){
    let index = courses[i].play_keys.indexOf(event.code)
    courses[i].play_listeners[index] = true}
  //Unmute a course
  if (courses[i].mute_key.includes(event.code)){
    courses[i].muted = false
  }
  //Unfret a coure
  if (courses[i].fret_keys.includes(event.code)){
    let fret = courses[i].fret_keys.indexOf(event.code) + 1
    courses[i].fretted.splice(courses[i].fretted.indexOf(fret), 1)
    if (is_playing(courses[i]) && fret > check_frets(courses[i])){
      string_sound(courses[i], hp_offset)
    }
  }
}}
  
//DRAW A COURSE
function course(strings, height){
  new paper.Path.Rectangle({
    point: [0, height],
    size: [nn.width, string_thickness],
    fillColor: string_color
  })
  
  if (strings === 2){
    new paper.Path.Rectangle({
      point: [0, height + string_spacing],
      size: [nn.width, string_thickness],
      fillColor: string_color
    })
  }
}
  
//DRAW THE LUTE ITSELF
function setup() {
  // Create and append the canvas to the document body
  const canvas = nn.create('canvas')
    .set({ width: nn.width, height: nn.height })
    .position(0, 0)
    .addTo('body')

  // Setup Paper.js with the created canvas
  paper.setup(canvas)

  // Draw the fretboard color
  new paper.Path.Rectangle({
    point: [0, 0],
    size: [nn.width, nn.height],
    fillColor: '#B7491F'
  })
  // Draw the body color
  new paper.Path.Rectangle({
    point: [(nn.width / (no_frets + 1)) * no_frets, 0],
    size: [nn.width, nn.height],
    fillColor: '#FAD0AD'
  })
  // Draw nut, then frets
  new paper.Path.Rectangle({
    point: [string_thickness * 0.1, 0],
    size: [string_thickness, nn.height],
    fillColor: nut_color
  })
  
  for (let i = 1; i < no_frets + 1; i++) {
    new paper.Path.Rectangle({
      point: [(nn.width / (no_frets + 1)) * i, 0],
      size: [string_thickness, nn.height],
      fillColor: fret_color
    })  
  }
  // Draw courses
  course(1, (nn.height / 4) * 0.5)
  course(2, (nn.height / 4) * 1.5)
  course(2, (nn.height / 4) * 2.5)
  course(2, (nn.height / 4) * 3.5)
  // 
  //animate()
}

function animate() {
  requestAnimationFrame(animate)
  //document.body.innerText = c1_fretted
}
  
nn.on('load', setup)
nn.on('keydown', keydown)
nn.on('keyup', keyup)
</script>