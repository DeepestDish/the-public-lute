<script src="https://cdn.jsdelivr.net/gh/netizenorg/netnet-standard-library/build/nn.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.12.15/paper-full.min.js"></script>
<script>
/* global nn, paper */

let string_thickness = nn.height / 64
//let course_spacing = nn.height / 4
let string_spacing = nn.height / 32
let string_color = "#FFFFFF"
let fret_color = "#CB9386"
let nut_color = "#FF2629"
let no_frets = 6

//"hp" means hammer/pull, which refers to
//hammer-ons and pull-offs. 

//I don't have samples for this, so I'm simulating it
//with a 200 millisecond sample offset.
let hp_offset = 0.15

//DEFINING AUDIO FILES
//COURSE 1
let c1_fret = 0
let c1_tune = 65 
let c1_samples = []
let c1_keys = ["Digit1", "Digit2", "Digit3", "Digit4", "Digit5", "Digit6"]

for (let i = c1_tune; i < c1_tune + no_frets + 1; i++){
  let note = nn.midiToNote(i)
  if (note.includes("#")){
    note = nn.midiToNote(i + 1)
    note = note.charAt(0) + "b" + note.charAt(1)
  }
  let path = "samples/course_1/" + note + ".mp3"
  //console.log(path)
  c1_samples.push(nn.create('audio').set({src: path}))
}

//console.log(c1_samples)
  
//LOOPING FUNCTIONS

//Makes a course resonate, whether it's a
//pluck or a hammer-on/pull-off.
function string_sound(sample_set, sample_offset){
    for (let i = 0; i < no_frets + 1; i++){
      if (i === c1_fret){
        sample_set[i].currentTime = sample_offset
        sample_set[i].play()
        //console.log(sample_set[i].src)
      }
      else{
        sample_set[i].pause()
      }
    }  
}

function is_playing(sample_set){
  let value = false
  for (let i = 0; i < no_frets + 1; i++){
    if (sample_set[i].paused){
      continue
    }
    else{
      value = true
      return value
      break
    }
  }
  return value
}
  
//AUDIO
function keydown(event){
  //console.log(event.code)
  
  //PLUCK COURSE 1
  if (event.code === "NumpadAdd" || event.code === "NumpadSubtract"){
    //console.log("attempting to play c1")
    string_sound(c1_samples, 0)
  }
  
  //FRET COURSE 1
  if (c1_keys.includes(event.code)){
    c1_fret = c1_keys.indexOf(event.code) + 1
    if (is_playing(c1_samples)){
      string_sound(c1_samples, hp_offset)
    }
  }
}

async function keyup(event){
  //UNFRET COURSE 1
  if (c1_keys.includes(event.code)){
    c1_fret = 0
    if (is_playing(c1_samples)){
      string_sound(c1_samples, hp_offset)
    }
  }
}
  
//DRAW A COURSE
function course(strings, height){
  new paper.Path.Rectangle({
    point: [0, height],
    size: [nn.width, string_thickness],
    fillColor: string_color
  })
  
  if (strings === 2){
    new paper.Path.Rectangle({
      point: [0, height + string_spacing],
      size: [nn.width, string_thickness],
      fillColor: string_color
    })
  }
}
  
//DRAW THE LUTE ITSELF
function setup() {
  // Create and append the canvas to the document body
  const canvas = nn.create('canvas')
    .set({ width: nn.width, height: nn.height })
    .position(0, 0)
    .addTo('body')

  // Setup Paper.js with the created canvas
  paper.setup(canvas)

  // Draw the fretboard color
  new paper.Path.Rectangle({
    point: [0, 0],
    size: [nn.width, nn.height],
    fillColor: '#B7491F'
  })
  // Draw the body color
  new paper.Path.Rectangle({
    point: [(nn.width / (no_frets + 1)) * no_frets, 0],
    size: [nn.width, nn.height],
    fillColor: '#FAD0AD'
  })
  // Draw nut, then frets
  new paper.Path.Rectangle({
    point: [string_thickness * 0.1, 0],
    size: [string_thickness, nn.height],
    fillColor: nut_color
  })
  
  for (let i = 1; i < no_frets + 1; i++) {
    new paper.Path.Rectangle({
      point: [(nn.width / (no_frets + 1)) * i, 0],
      size: [string_thickness, nn.height],
      fillColor: fret_color
    })  
  }
  // Draw courses
  course(1, (nn.height / 4) * 0.5)
  course(2, (nn.height / 4) * 1.5)
  course(2, (nn.height / 4) * 2.5)
  course(2, (nn.height / 4) * 3.5)

}

nn.on('load', setup)
nn.on('keydown', keydown)
nn.on('keyup', keyup)
</script>